\section{Application side} 
    
    Before delving deeper into the parts, we present the global system design diagram. We recognise two separate parts, the application side, where the Erlang system under test is, and the oscilloscope side, where the $\Delta$Q oscilloscope receives information from the system under test to display graphs.

    \begin{figure}[H]
        \begin{center}
            \includegraphics[width=\textwidth]{tikz/sut-stub-osc.pdf}
        \end{center}
        \caption{Global system design diagram.}
    \end{figure}


    \subsection{System under test} The system under test \textbf{(S.U.T)} is the Erlang system the engineer wishes to observe, it ideally is a system which already is instrumented with OpenTelemetry. The ideal system where $\Delta$QSD is more useful is a system that executes many independent instances of the same action \cite{dq-tut}. 
    
    \subsection{$\Delta$Q Adapter} The $\Delta$Q adapter is the \texttt{dqsd\_otel} Erlang application \cite{wrapper}, it starts and ends OpenTelemetry spans and translates them to outcome instances which are useful for the oscilloscope. This can be done thanks to probes being attached to the system under test, like an oscilloscope would! The outcome instances end normally like OpenTelemetry spans or, additionally, can timeout, given a custom timeout ($dMax$), and fail, \textit{according to user's definition of failure}. 
    
    Handling of OpenTelemetry spans which goes beyond starting and ending them is delegated to the user, who may wish to do further operations with their spans. 
    The adapter is called from the system under test and communicates outcome instances data to the oscilloscope via TCP. 
    
    The adapter can receive messages from the oscilloscope, the messages are about updating probe's $dMax$ or starting and stopping the sending of data to the oscilloscope.
    \subsection{Inserting probes in Erlang - From spans to outcome instances}
        OpenTelemetry spans are useful to carry context, attributes and baggage in a program. The plethora of attributes they have is nevertheless too much for the oscilloscope.

        To get the equivalent of spans for the oscilloscope, the adapter needs to be called at the starting events of a probe to start an instance of a probe, and at the ending events to end the outcome instance and send the data to the oscilloscope. The name given with \texttt{"start\_span"} is the name of the probe.

        \begin{minted}{erlang}
        % Start the outcome instance of probe. The call to dqsd_otel starts an OpenTelemetry span, as it contains a call to ?start_span(Name)
        {ProbeCtx, ProbePid} = dqsd_otel:start_span(<<"probe">>),   
        % Do work here ...
        %Example of with_span, the call to OpenTelemetry ?with_span is inside the adapter function, the function fun() -> ok end is executed inside dqsd_otel.
        dqsd_otel:with_span(<<"worker_2">>, fun() -> ok end), 
        %End the outcome instance of probe. This ends the OpenTelemetry span aswell. If the outcome instance has already timed out, the oscilloscope receives no message where the status is successful. Otherwise, this sends a message with startTime, endTime, the name "probe" and success status.
        dqsd_otel:end_span(ProbeCtx, ProbePid),

        
        \end{minted}
