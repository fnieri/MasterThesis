  \section{Outcome diagram}
        We define a grammar to create an outcome diagram in our oscilloscope, our grammar is a textual interpretation of the outcome expressions defined on the original paper of $\Delta$QSD. \\
        \subsection{Observables}
            Below is a way to define the observables in a system.
            \subsubsection{Outcome}
                In the definition of the system or of a probe, an outcome is defined with its name
        \begin{minted}{text}
            probe = outcomeName;
        \end{minted}
            \subsubsection{Probes}
                
        A probe can contain one component or a sequence of causally linked components. \\
        The user can define as many probes as they want, they have to be declared as follows:
   \begin{minted}{text}
        probe = component [-> component2];
        probe2 = newComponent -> anotherComponent;
   \end{minted}

    Probes will not be parsed after the system has been defined, in the case below, an error will be thrown.
    \begin{minted}{text}
        probe = ...;
        probe2 = ...;
        system = ...;
        probe3 = ...;
    \end{minted}
    
    Proes can be reused in other probes or in the system by adding a s: before they are used.
    \begin{minted}{text}
        probe3 = s:probe -> s:probe2;
    \end{minted}
 
        \subsection{Operators}
        To build a system, we must define some operators, below is how they can be defined. About first-to-finish, all-to-finish and probabilistic choice, they must contain at least two components, this is because the operations to calculate the DeltaQ of these operators rely on using the CDF of the components that define the operator.

        \subsubsection{Causal link}
            A causal link between two components can be defined by a right arrow from \texttt{component\_i} to \texttt{component\_j}
        \begin{minted}{text}
            component_i -> component_j 
        \end{minted}
        
        \subsubsection{All-to-finish operator}
            An all-to-finish operator needs to be defined as follows:
            \begin{minted}{text}
                a:name(component1, component2...)
            \end{minted}

        \subsubsection{First-to-finish operator}
            A first-to-finish operator needs to be defined as follows.
            \begin{minted}{text}
                f:name(component1, component2...)
            \end{minted} 

        \subsubsection{Probabilistic choice operator}
            A probabilistic choice operator needs to be defined as follows:
            \begin{minted}{text}
                p:name[probability_1, probability_2, ... probability_i](component_1, component_2, ..., component_i) 
            \end{minted}
            In addition to being comma separated, the number of probabilities inside the brackets must match the number of components inside the parentheses. For $n$ probabilites $p_i$, $0 < p_i < 1$, $\sum_{i = 0}^{n} p_i = 1$ 
        \subsection{Limitations}
            Our system has a few limitations compared to the theoretical applications of $\Delta$Q, namely, no cycles are allowed in the definition of a system.
        \begin{minted}{text}
            probe = s:probe_2;
            probe_2 = s:probe;
        \end{minted}
        The above example is not allowed and will raise an error when defined. 
    \section{Parser}
        To parse the system, we use the C++ ANTLR4 (ANother Tool for Language Recognition) library. 
        \subsection{ANTLR}
    ANTLR is a parser generator for reading, processing, executing or translating structured text files. ANTLR generates a parser that can build and walk parse trees [cite antlr site]. \\
 ANTLR is just one of the many parsers generators available in C++ (flex/bison, lex, yacc), although it presents certain limitations, its generated code is simpler to handle and less convoluted with respect to the other possibilities. \\
        ANTLR uses Adaptive LL(*) \textit{(ALL(*))} parser, namely, it will move grammar analysis to parse-time, without the use of static grammar analysis. [cite]

        \subsection{Grammar}
            ANTLR provides a yacc-like metalanguage to write grammars. Below, is the grammar for our system: [cite]
    \begin{minted}{text} 
grammar DQGrammar;

PROBE_ID: 's';
BEHAVIOR_TYPE: 'f' | 'a' | 'p';
NUMBER: [0-9]+('.'[0-9]+)?;
IDENTIFIER: [a-zA-Z_][a-zA-Z0-9_]*;
WS: [ \t\r\n]+ -> skip;

// Parser Rules
start: definition* system? EOF;

definition: IDENTIFIER '=' component_chain ';';
system: 'system' '=' component_chain ';'?;

component_chain
    : component ('->' component)*
;

component
    : behaviorComponent
    | probeComponent
    | outcome
;

behaviorComponent
    : BEHAVIOR_TYPE ':' IDENTIFIER ('[' probability_list ']')? '(' component_list ')'
;

probeComponent
    : PROBE_ID ':' IDENTIFIER
;

probability_list: NUMBER (',' NUMBER)+;
component_list: component_chain (',' component_chain)+;

outcome: IDENTIFIER;
    \end{minted}
             
    \subsubsection{Limitations}
        A previous version was implemented in Lark[cite], a python parsing toolkit. The python version was quickly discarded due to a more complicated integration between Python and C++. Lark provided Earley(SPPF) strategy which allowed for ambiguities to be resolved, which is not possible in ANTLR. \\
        For example the following system definition presents a few errors:
        \begin{minted}{text}
        probe = s -> a -> f -> p;
        \end{minted}
    While Lark could correctly guess that everything inside was an outcome, ANTLR expects \texttt{":"} after "s, a, f" and "p", thus, one can not name an outcome by these characters, as the parsers generator thinks that an operator or a probe will be next.
   
