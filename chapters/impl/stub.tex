\section{Wrapper}
    The wrapper, called \texttt{otel\_wrapper} is a rebar3 application built on top of OpenTelemetry, designed to be paired with the oscilloscope to observe an erlang application.
    \subsection{Motivation}
        To make our oscilloscope work, we must create custom spans. OpenTelemetry spans are not satisfying, imagine an overloaded system where a span is taking 10 seconds to complete, you wouldn't know it until the span is exported after 10 seconds! Thus the need to have a custom wrapper that can notify the oscilloscope when an outcome execution is taking longer than what was required by the user.
    \subsection{API}
        The wrapper exposes four functions to be used by the user, the wrapper is made to partially replace OpenTelemetry calls as for start and end. This is to make the open source less encumbrant. \\
        Moreover, the wrapper will always start OpenTelemetry spans but only start custom spans if the stub has been activated. The wrapper can be activated by: WIP 
        \subsubsection{span\_process}
                \texttt{span\_process} is the process responsible for handling the three statuses an execution can have: \texttt{success, fail, timeout}. The process is spawned by start\_span, upon being called, it will start a timer with time equal to the $dMax$ set by an user for the observable. 
        The process can receive three kinds of messages:
        \begin{itemize}
            \item \texttt{fail\_span}: This will send a custom span to the oscilloscope indicating that an execution of an observable has failed.
            \item \texttt{\{end\_span, end\_time\}}: This will send a custom span to the oscilloscope with the start and end time of the execution of the observable.
            \item \texttt{timeout}: If the program hasn't ended the span before $dMax$, the timer will send a \texttt{timeout} message and it will send a custom span to the oscilloscope indicating that an execution of an observable has taken $> dMax$.
        \end{itemize}
        The process is able to receive one and only message, if the execution times out and subsequently the span is ended, the oscilloscope will not be notified.
        \subsubsection{start\_span}
        \begin{minted}{erlang}        
-spec start_span(binary()) -> {opentelemetry:span_ctx(), pid() | ignore}.
        \end{minted}
        \paragraph{Parameter:}
        \begin{itemize}
            \item Name: Binary name of the observable
        \end{itemize} 
        \texttt{start\_span} incorporates OpenTelemetry \texttt{?start\_span(Name)} macro. If the wrapper has ben set as active and the user set a timeout for the name of the observable, the function will spawn a \texttt{span\_process} process with the timeout ($dMax$) of the observable. \\
        \paragraph{Return:} 
        The function returns either:
        \begin{itemize}
            \item  \texttt{\{SpanCtx, span\_process\_PID\}} if the wrapper is active and the observable's $dMax$ has been set 
            \item \texttt{\{SpanCtx, ignore\}} if one of the two previous conditions was not respected.
        \end{itemize}
        With SpanCtx being the context of the span created by OpenTelemetry.
        \subsubsection{with\_span}
            \begin{minted}{erlang}
-spec with_span(binary(), fun(() -> any())) -> any().
            \end{minted}
            \paragraph{Parameters:}
            \begin{itemize}
                \item Name: Binary name of the observable
                \item Fun: Zero-arity function representing the code of block that should run inside the \texttt{?with\_span} macro
            \end{itemize}
    \texttt{with\_span} incorporates OpenTelemetry \texttt{with\_span} macro. \\
        \paragraph{Return:}
            \texttt{with\_span} returns what \texttt{Fun} returns (\texttt{any()}).
        
        \subsubsection{end\_span}
            \begin{minted}{erlang}                
-spec end_span(opentelemetry:span_ctx(), pid() | ignore) -> ok | term().
            \end{minted}
            \paragraph{Parameters:}
            \begin{itemize}
                \item SpanCtx: The context of the span returned by \texttt{start\_span}.
                \item Pid: \texttt{span\_process\_PID} || \texttt{ignore}
            \end{itemize}

    As is the case for \texttt{start\_span}, \texttt{end\_span} incorporates an OpenTelemetry macro, in this case \texttt{?end\_span(Ctx)}. \\

        \subsubsection{fail\_span}
        \begin{minted}{erlang}        
-spec fail_span( pid() | ignore) -> ok | term().
        \end{minted}
        \paragraph{Parameter:}
             \begin{itemize}
                \item Pid: \texttt{ignore} || \texttt{span\_process\_PID}
            \end{itemize}
            \texttt{fail\_span} does not incorporate any OpenTelemetry macro, it is let up to the user to decide how to handle failures in execution. \\
           
