\section{Wrapper}
    The wrapper, called \texttt{dqsd\_otel} is a rebar3 \cite{rebar3} application built to replace OpenTelemetry calls and create outcome instances, it is designed to be paired with the oscilloscope to observe an Erlang application.
    
    \subsection{API}
        The wrapper functions to be used by the user are made to replace OpenTelemetry calls to macros as for \texttt{?start\_span} and \texttt{?with\_span} and \texttt{?end\_span}. This is to make the wrapper less of an encumbrance for the user. 

        Moreover, the wrapper will always start OpenTelemetry spans but only start outcome instances if the wrapper has been activated. The wrapper can be activated by the oscilloscope by pressing the "start wrapper" button and can be stopped via the "stop wrapper" button.
         
        \subsubsection{start\_span/1, start\_span/2}
        
        \begin{minted}{erlang}        
start_span/1: -spec start_span(binary()) -> {opentelemetry:span_ctx(), pid() | ignore}.
start_span/2: -spec start_span(binary(), map()) -> {opentelemetry:span_ctx(), pid() | ignore}.  
        \end{minted}
        
        \paragraph{Parameters:}
        \begin{itemize}
            \item Name: Binary name of the probe.
            \item Attributes: The OpenTelemetry span attributes (Only for start\_span/2).
        \end{itemize} 
        
        \texttt{start\_span} incorporates OpenTelemetry \texttt{?start\_span(Name)} macro.
        
        \paragraph{Return:} 
        The function returns either:
        \begin{itemize}
            \item  \texttt{\{SpanCtx, span\_process\_PID\}} if the wrapper is active and the probe's $dMax$ has been set.
            \item \texttt{\{SpanCtx, ignore\}} if one of the two previous conditions was not respected.
        \end{itemize}
        With SpanCtx being the context of the span created by OpenTelemetry.
        
        \subsubsection{with\_span/1, with\_span/2}
        
        \begin{minted}{erlang}
with_span/1: -spec with_span(binary(), fun(() -> any())) -> any().
with_span/2: -spec with_span(binary(), map(), fun(() -> any())) -> any().
        \end{minted}
         
        \paragraph{Parameters:}
            \begin{itemize}
                \item Name: Binary name of the probe.
                \item Fun: Zero-arity function representing the code of block that should run inside the \texttt{?with\_span} macro.
                \item Attributes: The OpenTelemetry span attributes (Only for with\_span/3).

            \end{itemize}

        \texttt{with\_span} incorporates OpenTelemetry \texttt{with\_span} macro. \\
        \paragraph{Return:}
            \texttt{with\_span} returns what \texttt{Fun} returns (\texttt{any()}).
        
        \subsubsection{end\_span}
            \begin{minted}{erlang}                
-spec end_span(opentelemetry:span_ctx(), pid() | ignore) -> ok | term().
            \end{minted}
            \paragraph{Parameters:}
            \begin{itemize}
                \item SpanCtx: The context of the span returned by \texttt{start\_span}.
                \item Pid: \texttt{span\_process\_PID} || \texttt{ignore}.
            \end{itemize}

    As is the case for \texttt{start\_span}, \texttt{end\_span} incorporates an OpenTelemetry macro, in this case \texttt{?end\_span(Ctx)}. \\

        \subsubsection{fail\_span}
        \begin{minted}{erlang}        
-spec fail_span( pid() | ignore) -> ok | term().
        \end{minted}
        \paragraph{Parameter:}
             \begin{itemize}
                \item Pid: \texttt{ignore} || \texttt{span\_process\_PID}.
            \end{itemize}
            \texttt{fail\_span} does not incorporate any OpenTelemetry macro, it is let up to the user to decide how to handle failures in execution. \\
        

        \subsubsection{span\_process}
            \texttt{span\_process} is the process, spawned by \texttt{start\_span}, responsible for handling the \texttt{end\_span, fail\_span, timeout} messages.

            Upon being spawned, the process starts a timer with time equal to the $dMax$ set by an user for the probe being observed, thanks to \texttt{erlang:send\_after}. When the timer runs out, it sends a \texttt{timeout} message to the process.
        
        The process can receive three kinds of messages:
        \begin{itemize}
            \item \texttt{\{end\_span, end\_time\}}: This will send a custom span to the oscilloscope with the start and end time of the execution of the probe.
            \item \texttt{\{fail\_span, end\_time\}}: This will send a custom span to the oscilloscope indicating that an execution of a probe has failed.
            \item \texttt{\{timeout, end\_time(StartTime + $dMax$)\}}: If the program hasn't ended the span before $dMax$, the timer will send a \texttt{timeout} message and it will send an outcome instance to the oscilloscope indicating that an execution of a probe has timed out.
        \end{itemize}
        The process is able to receive one and only message, if the execution times out and subsequently the span is ended, the oscilloscope will not be notified as the process is defunct. This is assured by Erlang documentation:
        \begin{center}
            \textit{If the message signal was sent using a process alias that is no longer active, the message signal will be dropped.} \cite{erl-s}
        \end{center}

    \subsection{Handling outcome instances}
        To create outcome instances of a probe we must obtain three important informations:
        \begin{itemize}
            \item Its name.
            \item The time when the span was started.
            \item Its $dMax$.
        \end{itemize}
        
        They start time and end time are supplied by calling this function:
        \begin{minted}{erlang}
        StartTime/EndTime = erlang:system_time(nanosecond).
        \end{minted}
        The name is given when starting a span and the $dMax$ is stored in a dictionary in the wrapper. 

            The outcome instance is created only if two conditions are met: the wrapper has been set as active and the user set a timeout for the probe, the functions will spawn a \texttt{span\_process} process, passing along all the necessary informations. \\
        Once the span is subsequently ended/timed out/failed, the function \texttt{send\_span} creates a message carrying all the informations and sends it to the C++ server. The formatting of the messages is the following:
        \begin{minted}{text}
            n:Observed name, b: Start time (beginning), e: End time (end or deadline), s: The status
        \end{minted}

    \subsection{TCP connection}
        The wrapper is composed of two \texttt{gen\_server} which handle communication to and from the oscilloscope. This gen\_server behaviour allows the wrapper to send spans asynchronously to the oscilloscope.

        \subsubsection{TCP server}
            The TCP server is responsible for receiving commands from the oscilloscope. It can be run by setting its IP and port via:
            \begin{minted}{erlang}
                -spec start_server(string() | binary() | tuple(), integer()) -> ok | {error, Reason}
            \end{minted}
            The oscilloscope can send commands to the wrapper, these commands are:
            \begin{itemize}
                \item \texttt{start\_stub}: This command sets the wrapper as active, it can now send outcome instances to the oscilloscope if the probe's $dMax$s are defined.
                \item \texttt{stop\_stub}: This commands sets the wrapper as inactive, it will no longer send outcome instances to the oscilloscope.
                \item \texttt{set\_timeout;probeName;timeout}: This command indicates to the wrapper to set the $dMax = \text{timeout}$ for a probe, a limit of the wrapper is that erlang:send\_after does not accept floats as timeouts, so the timeout will be rounded to the nearest integer.
            \end{itemize}

        \subsubsection{TCP client}
            The TCP client allows the wrapper to send the spans to the oscilloscope.
            The client connects over TCP to the oscilloscope by connecting to the oscilloscope server'address and opens a socket where it can send the outcome instances.
            \begin{minted}{erlang}
                -spec try_connect(string() | binary(), integer()) -> ok.
            \end{minted}
