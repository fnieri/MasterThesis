\section{Wrapper}
    The wrapper, called \texttt{otel\_wrapper} is a rebar3 application built to replace OpenTelemetry calls and create custom spans, it is designed to be paired with the oscilloscope to observe an erlang application.
    
    \subsection{API}
        The wrapper functions to be used by the user are made to replace OpenTelemetry calls to macros as for \texttt{?start\_span} and \texttt{?with\_span} and \texttt{?end\_span}. This is to make the wrapper less of an encumbrance for the user. \\
        Moreover, the wrapper will always start OpenTelemetry spans but only start custom spans if the stub has been activated. The wrapper can be activated by: WIP 
        
       
        \subsubsection{start\_span/1, start\_span/2}
        
        \begin{minted}{erlang}        
start_span/1: -spec start_span(binary()) -> {opentelemetry:span_ctx(), pid() | ignore}.
start_span/2: -spec start_span(binary(), map()) -> {opentelemetry:span_ctx(), pid() | ignore}.  
        \end{minted}
        
        \paragraph{Parameters:}
        \begin{itemize}
            \item Name: Binary name of the observable
            \item Attributes: The OpenTelemetry span attributes (Only for start\_span/2)
        \end{itemize} 
        
        \texttt{start\_span} incorporates OpenTelemetry \texttt{?start\_span(Name)} macro.
        
        \paragraph{Return:} 
        The function returns either:
        \begin{itemize}
            \item  \texttt{\{SpanCtx, span\_process\_PID\}} if the wrapper is active and the observable's $dMax$ has been set 
            \item \texttt{\{SpanCtx, ignore\}} if one of the two previous conditions was not respected.
        \end{itemize}
        With SpanCtx being the context of the span created by OpenTelemetry.
        
        \subsubsection{with\_span/1, with\_span/2}
        
        \begin{minted}{erlang}
with_span/1: -spec with_span(binary(), fun(() -> any())) -> any().
with_span/2: -spec with_span(binary(), map(), fun(() -> any())) -> any().
        \end{minted}
         
        \paragraph{Parameters:}
            \begin{itemize}
                \item Name: Binary name of the observable
                \item Fun: Zero-arity function representing the code of block that should run inside the \texttt{?with\_span} macro
                \item Attributes: The OpenTelemetry span attributes (Only for with\_span/3)
            \end{itemize}

        \texttt{with\_span} incorporates OpenTelemetry \texttt{with\_span} macro. \\
        \paragraph{Return:}
            \texttt{with\_span} returns what \texttt{Fun} returns (\texttt{any()}).
        
        \subsubsection{end\_span}
            \begin{minted}{erlang}                
-spec end_span(opentelemetry:span_ctx(), pid() | ignore) -> ok | term().
            \end{minted}
            \paragraph{Parameters:}
            \begin{itemize}
                \item SpanCtx: The context of the span returned by \texttt{start\_span}.
                \item Pid: \texttt{span\_process\_PID} || \texttt{ignore}
            \end{itemize}

    As is the case for \texttt{start\_span}, \texttt{end\_span} incorporates an OpenTelemetry macro, in this case \texttt{?end\_span(Ctx)}. \\

        \subsubsection{fail\_span}
        \begin{minted}{erlang}        
-spec fail_span( pid() | ignore) -> ok | term().
        \end{minted}
        \paragraph{Parameter:}
             \begin{itemize}
                \item Pid: \texttt{ignore} || \texttt{span\_process\_PID}
            \end{itemize}
            \texttt{fail\_span} does not incorporate any OpenTelemetry macro, it is let up to the user to decide how to handle failures in execution. \\
        

        \subsubsection{span\_process}
            \texttt{span\_process} is the process, spawned by \texttt{start\_span}, responsible for handling the \texttt{end\_span, fail\_span, timeout} messages. \\
            Upon being spawned, the process starts a timer with time equal to the $dMax$ set by an user for the observable being observed, thanks to \texttt{erlang:send\_after}. when the timer runs out, it sends a \texttt{timeout} message to the process.
        The process can receive three kinds of messages:
        \begin{itemize}
            \item \texttt{\{end\_span, end\_time\}}: This will send a custom span to the oscilloscope with the start and end time of the execution of the observable.
            \item \texttt{fail\_span}: This will send a custom span to the oscilloscope indicating that an execution of an observable has failed.
            \item \texttt{timeout}: If the program hasn't ended the span before $dMax$, the timer will send a \texttt{timeout} message and it will send a custom span to the oscilloscope indicating that an execution of an observable has taken $> dMax$.
        \end{itemize}
        The process is able to receive one and only message, if the execution times out and subsequently the span is ended, the oscilloscope will not be notified as the process is defunct. This is assured by Erlang documentation: \\
        \textit{If the message signal was sent using a process alias that is no longer active, the message signal will be dropped}. %https://www.erlang.org/doc/system/ref_man_processes#sync-comm

    \subsection{Handling outcome instances}
        To create custom spans of the outcome instances we must obtain three important informations:
        \begin{itemize}
            \item The name of the observed outcome or probe
            \item The time when the span was started
            \item The $dMax$ of the observed
        \end{itemize}
        
        They are all supplied upon starting a span with \texttt{otel\_wrapper:[start\_span, with\_span]} by calling 
        
        \begin{minted}{erlang}
        StartTime = erlang:system_time(nanosecond),
        \end{minted}

            The custom span is created only if two conditions are met: the wrapper has been set as active and the user set a timeout for the name of the observable, the functions will spawn a \texttt{span\_process} process, passing along all the necessary informations. \\
        Once the span is subsequently ended/timed out/failed, the function \texttt{send\_span} creates a message carrying all the informations and sends it to the C++ server. The formatting of the messages is the following:
        \begin{minted}{text}
            n:Observed name, b: Start time (beginning), e: End time (if end_span was received), s: The status
        \end{minted}

    \subsection{TCP connection}
        The wrapper is composed of two \texttt{gen\_server} which handle communication to and from the oscilloscope. This gen\_server behaviour allows the wrapper to send spans asynchronously to the oscilloscope.

        \subsubsection{TCP server}
            The TCP server listens by default on localhost at port 8081, the user can define a port and ip to listen at.

            The oscilloscope can send commands to the stub, these commands are:
            \begin{itemize}
                \item \texttt{start\_stub}: This command sets the stub as active, it can now send spans to the oscilloscope if the items are defined.
                \item \texttt{stop\_stub}: This commands sets the stub as inactive, it will no longer send spans to the oscilloscope
                \item \texttt{set\_timeout;probeName;timeout}: This command indicates to the stub to set the $dMax$ for a probe to timeOut, a limit of the stub is that erlang:send\_after does not accept floats as timeouts, so the timeout will be rounded to the nearest integer
            \end{itemize}

        \subsubsection{TCP client}
            The TCP client allows the stub to send the spans to the oscilloscope, by default the oscilloscope is on localhost:8080, but that can be changed by the user.

            The client connects over TCP to the oscilloscope and opens a socket where it can send the spans.
